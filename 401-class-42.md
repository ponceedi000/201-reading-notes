## Readings: Pythonisms
***

### [Dunder Methods](https://dbader.org/blog/python-dunder-methods)
- What Are Dunder Methods?
  * In Python, special methods are a set of predefined methods you can use to enrich your classes.
  * They are easy to recognize b/c they start and end with double underscores
  * "Dunder Methods": a short form of "double under"
  * Also refered to as "magic methods"

- Special Methods and the Python Data Model
  * The Python data model and lets developers tap into rich language features like sequences, iteration, operator overloading, attribute access, etc.

- Enriching a Simple Account Class: common dunder methods:
  * Initialization of new objects
  * Object representation
  * Enable iteration
  * Operator overloading (comparison)
  * Operator overloading (addition)
  * Method invocation
  * Context manager support (with statement)

- Object Initialization: __init__
  * Right upon starting a class, we need a special method to construct objects from our class (e.g. constructor)
  * The constructor takes care of setting up the object.
EX: In this cases it recieves the owner name, an optional start amount and defines an internal transactions list to keep track of deposits and withdrawls.
```
class Account:
    """A simple account class"""

    def __init__(self, owner, amount=0):
        """
        This is the constructor that lets us create
        objects from this class
        """
        self.owner = owner
        self.amount = amount
        self._transactions = []
        
// This allows us to create new accounts like this:
>>> acc = Account('bob')  # default amount = 0
>>> acc = Account('bob', 10)
```

- Object Representation: __str__, __repr__: It is common practice to provide a string representation of your object for the consumer of your class. Here are two differnt ways to do this using dunder methods:
  * **__repr__:** The “official” string representation of an object. This is how you would make an object of the class. The goal of __repr__ is to be unambiguous.
  * **__str__:** The “informal” or nicely printable string representation of an object. This is for the enduser.
```
class Account:
    # ... (see above)

    def __repr__(self):
        return 'Account({!r}, {!r})'.format(self.owner, self.amount)

    def __str__(self):
        return 'Account of {} with starting amount: {}'.format(
            self.owner, self.amount)
            
>>> str(acc)
'Account of bob with starting amount: 10'

>>> print(acc)
"Account of bob with starting amount: 10"

>>> repr(acc)
"Account('bob', 10)"
```





### [Iterators](https://dbader.org/blog/python-iterators)


### [Generators](https://dbader.org/blog/python-generators)


## Videos
### [What are Generators](https://realpython.com/lessons/what-are-python-generators/)

### Bookmark/Slim
- [Decorators](https://realpython.com/primer-on-python-decorators/)


***
 ## End of Notes
